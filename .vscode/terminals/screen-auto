#!/usr/bin/env bash
set -euo pipefail

# Set terminal title IMMEDIATELY to avoid showing "bash" before the real name
# The profile provider sets IMMORTERM_DISPLAY_NAME in the environment
if [[ -n "${IMMORTERM_DISPLAY_NAME:-}" ]]; then
  printf '\033]0;%s\007' "$IMMORTERM_DISPLAY_NAME"
fi

cd "$(dirname "${BASH_SOURCE[0]}")/../.."
PROJECT="$(basename "$PWD" | tr '[:upper:]' '[:lower:]')"
JSON=".vscode/restore-terminals.json"
PROJECT_DIR="$PWD"
LOGS_DIR="$PROJECT_DIR/.vscode/terminals/logs"
PENDING_DIR="$PROJECT_DIR/.vscode/terminals/pending"

# Screen binary - use configured path or fall back to 'immorterm'
SCREEN="${IMMORTERM_SCREEN_BINARY:-immorterm}"

# Check if screen binary is available - graceful fallback if not
if ! command -v "$SCREEN" >/dev/null 2>&1; then
  echo ""
  echo "╔═══════════════════════════════════════════════════════════════════╗"
  echo "║  ImmorTerm: Screen binary '$SCREEN' not found                     ║"
  echo "╠═══════════════════════════════════════════════════════════════════╣"
  echo "║  Terminal persistence is disabled. Install immorterm:      ║"
  echo "║                                                                   ║"
  echo "║    brew install lonormaly/tap/immorterm                    ║"
  echo "║                                                                   ║"
  echo "║  Then reload VS Code (Cmd+Shift+P → 'Reload Window')              ║"
  echo "╚═══════════════════════════════════════════════════════════════════╝"
  echo ""
  # Fall back to standard shell so user can still work
  exec "${SHELL:-/bin/zsh}"
fi

mkdir -p "$PROJECT_DIR/.vscode" "$LOGS_DIR" "$PENDING_DIR"
[[ -f "$JSON" ]] || echo '{"artificialDelayMilliseconds":800,"terminals":[]}' > "$JSON"

# Debug log for auto-resume troubleshooting
DEBUG_LOG="$PROJECT_DIR/.vscode/terminals/logs/auto-resume.log"
debug() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$DEBUG_LOG"; }

# Check if extension pre-generated identity (env vars set by ImmorTermProfileProvider)
# This prevents duplicates - extension already created the pending file
if [[ -n "${IMMORTERM_WINDOW_ID:-}" ]] && [[ -n "${IMMORTERM_DISPLAY_NAME:-}" ]]; then
  # Extension created the terminal - use pre-generated values
  WINDOW="$IMMORTERM_WINDOW_ID"
  DISPLAY_NAME="$IMMORTERM_DISPLAY_NAME"
  SESSION="${PROJECT}-${WINDOW}"
  debug "EXTENSION terminal: window=$WINDOW, display=$DISPLAY_NAME (env vars)"
  # Extension already created pending file, spawn reconciler to process it
  "$PROJECT_DIR/.vscode/terminals/screen-reconcile" &
elif [[ -n "${1:-}" ]]; then
  # Restored terminal: arg is window name (used as session name)
  # optional second arg is display name (friendly name for tab)
  WINDOW="$1"
  DISPLAY_NAME="${2:-$WINDOW}"  # Use display name if provided, else windowId
  SESSION="${PROJECT}-${WINDOW}"
  debug "RESTORED terminal: window=$WINDOW, display=$DISPLAY_NAME"
else
  # NEW terminal without extension (fallback, shouldn't happen normally)
  WINDOW="$$-$(head -c6 /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | head -c8)"
  SESSION="${PROJECT}-${WINDOW}"

  # Calculate next friendly name (pax-1, pax-2, etc.)
  # Find highest existing N and add 1
  if [[ -f "$JSON" ]]; then
    MAX_N=$(jq -r --arg p "${PROJECT}-" '.terminals[]?.splitTerminals[]?.name // empty | select(startswith($p)) | ltrimstr($p) | tonumber' "$JSON" 2>/dev/null | sort -n | tail -1)
    NEXT_N=$((${MAX_N:-0} + 1))
  else
    NEXT_N=1
  fi
  DISPLAY_NAME="${PROJECT}-${NEXT_N}"

  # Create pending file with BOTH windowId and displayName
  # Format: "windowId displayName"
  echo "$WINDOW $DISPLAY_NAME" > "$PENDING_DIR/$WINDOW"

  # Spawn reconciler in background (will add pending entries to JSON)
  "$PROJECT_DIR/.vscode/terminals/screen-reconcile" &
fi

LOGFILE="$LOGS_DIR/${SESSION}.log"

# Export project directory BEFORE creating session so shell inherits it
export SCREEN_PROJECT_DIR="$PROJECT_DIR"
# Export window ID for pending rename detection
export SCREEN_WINDOW_ID="$WINDOW"
# Export window name for shell title initialization
export SCREEN_WINDOW_NAME="$DISPLAY_NAME"

# Print log history before attaching (so it appears in native scroll buffer)
# Limit to last 20000 lines to prevent VS Code crashes on large logs
LOG_LINES=20000
if [[ -f "$LOGFILE" ]]; then
  tail -n "$LOG_LINES" "$LOGFILE"
fi

# Check if session exists or needs to be created
SESSION_IS_NEW=false
if ! "$SCREEN" -S "$SESSION" -Q select . >/dev/null 2>&1; then
  SESSION_IS_NEW=true
  debug "SESSION_IS_NEW=true for $SESSION (creating new screen)"
  # Create new detached session with large scrollback buffer (50k lines)
  # Shell will inherit SCREEN_PROJECT_DIR from this parent process
  # NOTE: Do NOT use -L -Logfile here as it may truncate the existing log file!
  "$SCREEN" -dmS "$SESSION" -c "$PROJECT_DIR/.vscode/terminals/screenrc" -h 50000

  # Enable logging AFTER session creation (appends, doesn't truncate)
  "$SCREEN" -S "$SESSION" -X logfile "$LOGFILE"
  "$SCREEN" -S "$SESSION" -X log on

  # Set the screen window title immediately (before shell can override it)
  "$SCREEN" -S "$SESSION" -X title "$DISPLAY_NAME"

  # Note: shell-init.zsh is sourced automatically by shell-wrapper.zsh (set in screenrc)

  # If this is a RESTORED terminal (has windowId arg) and session was lost (laptop restart),
  # check if there's a Claude session to auto-resume
  if [[ -n "${1:-}" ]]; then
    CLAUDE_SESSION_ID=$(jq -r --arg wid "$WINDOW" \
      '.terminals[]?.splitTerminals[]? | select(.windowId == $wid) | .claudeSessionId // empty' \
      "$JSON" 2>/dev/null)
    debug "Checking auto-resume: window=$WINDOW, claudeSessionId=${CLAUDE_SESSION_ID:-<none>}"

    if [[ -n "$CLAUDE_SESSION_ID" ]]; then
      debug "AUTO-RESUME: sending 'claude --resume $CLAUDE_SESSION_ID' to $SESSION"
      # Auto-resume Claude session in this screen
      "$SCREEN" -S "$SESSION" -X stuff "claude --resume $CLAUDE_SESSION_ID\n"
    else
      debug "No claudeSessionId found for $WINDOW, skipping auto-resume"
    fi
  fi
else
  debug "SESSION_IS_NEW=false for $SESSION (attaching to existing)"
  # Note: shell-init.zsh is sourced automatically by shell-wrapper.zsh (set in screenrc)
  # No need to inject commands - the wrapper handles it for all sessions
fi

# Set VS Code terminal tab name BEFORE exec screen
# OSC 0 sequence sets terminal title - must be sent before screen takes over
# otherwise VS Code shows "screen-5.0.1" (the process name)
printf '\033]0;%s\007' "$DISPLAY_NAME"

# Attach to the session
exec "$SCREEN" -xRR -S "$SESSION"
