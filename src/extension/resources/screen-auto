#!/usr/bin/env bash
set -euo pipefail

# Set terminal title IMMEDIATELY to avoid showing "bash" before the real name
# For new terminals: profile provider sets IMMORTERM_DISPLAY_NAME in the environment
# For restored terminals: name is passed as $2 argument
if [[ -n "${IMMORTERM_DISPLAY_NAME:-}" ]]; then
  printf '\033]0;%s\007' "$IMMORTERM_DISPLAY_NAME"
elif [[ -n "${2:-}" ]]; then
  printf '\033]0;%s\007' "$2"
fi

cd "$(dirname "${BASH_SOURCE[0]}")/../.."
PROJECT="$(basename "$PWD" | tr '[:upper:]' '[:lower:]')"
JSON=".vscode/restore-terminals.json"
PROJECT_DIR="$PWD"
LOGS_DIR="$PROJECT_DIR/.vscode/terminals/logs"
PENDING_DIR="$PROJECT_DIR/.vscode/terminals/pending"

# Screen binary - use configured path, local dev version, or fall back to 'immorterm'
# Priority: env var > local dev build > homebrew installed
if [[ -n "${IMMORTERM_SCREEN_BINARY:-}" ]]; then
  SCREEN="$IMMORTERM_SCREEN_BINARY"
elif [[ -x "$HOME/Development/immorterm/bin/immorterm" ]]; then
  SCREEN="$HOME/Development/immorterm/bin/immorterm"
else
  SCREEN="immorterm"
fi

# Check if screen binary is available - graceful fallback if not
if ! command -v "$SCREEN" >/dev/null 2>&1; then
  echo ""
  echo "╔═══════════════════════════════════════════════════════════════════╗"
  echo "║  ImmorTerm: Screen binary '$SCREEN' not found                     ║"
  echo "╠═══════════════════════════════════════════════════════════════════╣"
  echo "║  Terminal persistence is disabled. Install immorterm:      ║"
  echo "║                                                                   ║"
  echo "║    brew install lonormaly/tap/immorterm                    ║"
  echo "║                                                                   ║"
  echo "║  Then reload VS Code (Cmd+Shift+P → 'Reload Window')              ║"
  echo "╚═══════════════════════════════════════════════════════════════════╝"
  echo ""
  # Fall back to standard shell so user can still work
  exec "${SHELL:-/bin/zsh}"
fi

mkdir -p "$PROJECT_DIR/.vscode" "$LOGS_DIR" "$PENDING_DIR"
[[ -f "$JSON" ]] || echo '{"artificialDelayMilliseconds":0,"terminals":[]}' > "$JSON"

# Debug log for auto-resume troubleshooting
DEBUG_LOG="$PROJECT_DIR/.vscode/terminals/logs/auto-resume.log"
debug() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$DEBUG_LOG"; }

# Dump filtered log to VS Code scrollback buffer
# Filters: escape sequences, zsh PROMPT_SP markers, blank lines
dump_filtered_log() {
  local logfile="$1"
  local lines="${2:-20000}"
  echo ""
  tail -n "$lines" "$logfile" \
    | tr '\r' '\n' \
    | sed -E 's/\x1b\[[0-9;]*[HJK]//g' \
    | perl -ne 'my $s = $_; $s =~ s/\e\[[0-9;?]*[a-zA-Z]//g; $s =~ s/\e\][^\a]*\a//g; print unless $s =~ /^%?\s*$/' \
    | sed -E 's/^[[:space:]]{20,}(.)/\1/' \
    | grep -v '^[[:space:]]*$'
}

# Check if extension pre-generated identity (env vars set by ImmorTermProfileProvider)
# This prevents duplicates - extension already created the pending file
if [[ -n "${IMMORTERM_WINDOW_ID:-}" ]] && [[ -n "${IMMORTERM_DISPLAY_NAME:-}" ]]; then
  # Extension created the terminal - use pre-generated values
  WINDOW="$IMMORTERM_WINDOW_ID"
  DISPLAY_NAME="$IMMORTERM_DISPLAY_NAME"
  SESSION="${PROJECT}-${WINDOW}"
  debug "EXTENSION terminal: window=$WINDOW, display=$DISPLAY_NAME (env vars)"
  # Extension already created pending file, spawn reconciler to process it
  "$PROJECT_DIR/.vscode/terminals/screen-reconcile" &
elif [[ -n "${1:-}" ]]; then
  # Restored terminal: arg is window name (used as session name)
  # optional second arg is display name (friendly name for tab)
  WINDOW="$1"
  DISPLAY_NAME="${2:-$WINDOW}"  # Use display name if provided, else windowId
  SESSION="${PROJECT}-${WINDOW}"
  debug "RESTORED terminal: window=$WINDOW, display=$DISPLAY_NAME"
else
  # NEW terminal without extension (fallback, shouldn't happen normally)
  WINDOW="$$-$(head -c6 /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | head -c8)"
  SESSION="${PROJECT}-${WINDOW}"

  # Calculate next friendly name (pax-1, pax-2, etc.)
  # Find highest existing N and add 1
  if [[ -f "$JSON" ]]; then
    MAX_N=$(jq -r --arg p "${PROJECT}-" '.terminals[]?.splitTerminals[]?.name // empty | select(startswith($p)) | ltrimstr($p) | tonumber' "$JSON" 2>/dev/null | sort -n | tail -1)
    NEXT_N=$((${MAX_N:-0} + 1))
  else
    NEXT_N=1
  fi
  DISPLAY_NAME="${PROJECT}-${NEXT_N}"

  # Create pending file with BOTH windowId and displayName
  # Format: "windowId displayName"
  echo "$WINDOW $DISPLAY_NAME" > "$PENDING_DIR/$WINDOW"

  # Spawn reconciler in background (will add pending entries to JSON)
  "$PROJECT_DIR/.vscode/terminals/screen-reconcile" &
fi

LOGFILE="$LOGS_DIR/${SESSION}.log"

# Export environment BEFORE creating session so screen inherits it
# These variables are available to backtick commands and the interactive shell
export SCREEN_PROJECT_DIR="$PROJECT_DIR"
export IMMORTERM_SCREEN_BINARY="$SCREEN"  # Needed by screen-mem to detect parent process
export SCREEN_WINDOW_ID="$WINDOW"
export SCREEN_WINDOW_NAME="$DISPLAY_NAME"
export IMMORTERM_BASE_NAME="$DISPLAY_NAME"  # Immutable base name for title construction
# IMMORTERM_RENAMES_DIR is set by VS Code extension (screen-integration.ts)
# Re-export to ensure screen server process inherits it for title file notifications
export IMMORTERM_RENAMES_DIR="${IMMORTERM_RENAMES_DIR:-$PROJECT_DIR/.vscode/terminals/renames}"

# Log dump moved to NEW SESSION block only (see below).
# For reattachment to existing sessions, screen's own scrollback is sufficient.
# This prevents duplication: VS Code scrollback + screen scrollback showing same content.

# ============================================================================
# SESSION MANAGEMENT
# ============================================================================
# Find existing sessions matching our session name.
# Returns the full "PID.name" identifier for unambiguous operations.
# Prefers "Detached" sessions over "Dead/Remote" ones.
# If multiple healthy sessions exist, returns the one with highest PID (most recent).
find_best_session() {
  local name="$1"
  local sessions
  sessions=$("$SCREEN" -ls 2>/dev/null | grep -E "[0-9]+\.$name[[:space:]]" || true)

  if [[ -z "$sessions" ]]; then
    return 1  # No sessions found
  fi

  # First, try to find a "Detached" session (healthy, ready to attach)
  local detached
  detached=$(echo "$sessions" | grep "Detached" | sort -t. -k1 -n -r | head -1 | awk '{print $1}')
  if [[ -n "$detached" ]]; then
    echo "$detached"
    return 0
  fi

  # Next, try "Attached" sessions (might be attached to dead display, -D will fix)
  local attached
  attached=$(echo "$sessions" | grep "Attached" | sort -t. -k1 -n -r | head -1 | awk '{print $1}')
  if [[ -n "$attached" ]]; then
    echo "$attached"
    return 0
  fi

  # No healthy sessions - all are "Dead" or "Remote"
  return 1
}

# Clean up dead/remote sessions to prevent accumulation
# Note: screen -X quit and screen -wipe often fail to remove "Remote or dead" sessions
# So we delete the socket files directly from ~/.screen/
cleanup_dead_sessions() {
  local name="$1"
  local dead_sessions
  dead_sessions=$("$SCREEN" -ls 2>/dev/null | grep -E "[0-9]+\.$name[[:space:]]" | grep -E "Dead|Remote" || true)

  if [[ -n "$dead_sessions" ]]; then
    debug "Found dead sessions for $name, cleaning up..."

    # Get the screen socket directory (usually ~/.screen or /tmp/screens/S-$USER)
    local screen_dir="${SCREENDIR:-$HOME/.screen}"

    echo "$dead_sessions" | while read -r line; do
      local full_id
      full_id=$(echo "$line" | awk '{print $1}')
      if [[ -n "$full_id" ]]; then
        # Try screen -X quit first (works for some dead sessions)
        "$SCREEN" -S "$full_id" -X quit 2>/dev/null || true

        # Also delete the socket file directly (this actually works for "Remote or dead")
        local socket_file="$screen_dir/$full_id"
        if [[ -S "$socket_file" ]]; then
          rm -f "$socket_file"
          debug "Deleted socket file: $socket_file"
        fi

        debug "Cleaned up dead session: $full_id"
      fi
    done

    # Run screen -wipe to finalize cleanup
    "$SCREEN" -wipe >/dev/null 2>&1 || true
  fi
}

# Main session logic
SESSION_IS_NEW=false
FULL_SESSION_ID=""
SKIP_CLEAR=false  # Don't clear screen for Claude sessions on reattachment

# First, clean up any dead sessions with our name
cleanup_dead_sessions "$SESSION"

# Now find the best healthy session to attach to
FULL_SESSION_ID=$(find_best_session "$SESSION" || true)

if [[ -z "$FULL_SESSION_ID" ]]; then
  # No healthy session found - create a new one
  SESSION_IS_NEW=true
  debug "SESSION_IS_NEW=true for $SESSION (creating new screen)"

  # Check if this terminal has a Claude session to auto-resume
  # If so, skip log dump - Claude's TUI output is full of escape sequences
  # and --resume will restore conversation context anyway
  WILL_AUTO_RESUME=""
  if [[ -n "${1:-}" ]]; then
    WILL_AUTO_RESUME=$(jq -r --arg wid "$WINDOW" \
      '.terminals[]?.splitTerminals[]? | select(.windowId == $wid) | .claudeSessionId // empty' \
      "$JSON" 2>/dev/null)
  fi

  # Dump log history to VS Code's native scroll buffer (NEW sessions only)
  # Skip for Claude sessions - their TUI output doesn't render well and --resume restores context
  if [[ -z "$WILL_AUTO_RESUME" ]] && [[ -f "$LOGFILE" ]]; then
    debug "Dumping log history for non-Claude session"
    dump_filtered_log "$LOGFILE"
  elif [[ -n "$WILL_AUTO_RESUME" ]]; then
    debug "Skipping log dump - Claude session will auto-resume"
  fi

  # Create new detached session with large scrollback buffer (50k lines)
  # Shell will inherit SCREEN_PROJECT_DIR from this parent process
  # NOTE: Do NOT use -L -Logfile here as it may truncate the existing log file!
  "$SCREEN" -dmS "$SESSION" -c "$PROJECT_DIR/.vscode/terminals/screenrc" -h 50000

  # Get the full session ID of the newly created session
  # Use fast polling instead of fixed sleep (typically completes in <50ms)
  for attempt in 1 2 3 4 5; do
    FULL_SESSION_ID=$(find_best_session "$SESSION" 2>/dev/null) && break
    sleep 0.02  # 20ms between attempts, max 100ms total
  done
  [[ -z "$FULL_SESSION_ID" ]] && FULL_SESSION_ID="$SESSION"
  debug "Created new session: $FULL_SESSION_ID"

  # Enable logging AFTER session creation (appends, doesn't truncate)
  "$SCREEN" -S "$FULL_SESSION_ID" -X logfile "$LOGFILE"
  "$SCREEN" -S "$FULL_SESSION_ID" -X log on

  # Set the screen window title immediately (before shell can override it)
  "$SCREEN" -S "$FULL_SESSION_ID" -X title "$DISPLAY_NAME"

  # Set environment variables for backtick commands (screen's internal env, not shell env)
  # This is required because backticks query screen's internal environment table, NOT shell exports
  "$SCREEN" -S "$FULL_SESSION_ID" -X setenv IMMORTERM_SCREEN_BINARY "$SCREEN"
  # Pass renames directory so C code writes title files to project-specific location
  [[ -n "$IMMORTERM_RENAMES_DIR" ]] && "$SCREEN" -S "$FULL_SESSION_ID" -X setenv IMMORTERM_RENAMES_DIR "$IMMORTERM_RENAMES_DIR"

  # Note: shell-init.zsh is sourced automatically via ZDOTDIR/.zshrc (set in screenrc)

  # If this terminal has a Claude session to auto-resume (already checked above)
  if [[ -n "$WILL_AUTO_RESUME" ]]; then
    debug "AUTO-RESUME: sending 'claude --resume $WILL_AUTO_RESUME' to $FULL_SESSION_ID"
    # Auto-resume Claude session in this screen
    "$SCREEN" -S "$FULL_SESSION_ID" -X stuff "claude --resume $WILL_AUTO_RESUME\n"
  fi
else
  debug "SESSION_IS_NEW=false for $SESSION (attaching to existing: $FULL_SESSION_ID)"
  # Note: shell-init.zsh is sourced automatically via ZDOTDIR/.zshrc (set in screenrc)
  # No need to inject commands - ZDOTDIR handles it for all sessions

  # For reattachment: check if this is an interactive session (has claudeSessionId)
  # Interactive sessions (Claude) redraw themselves - dumping log causes duplication
  # Non-interactive sessions need log dump to restore scrollback context
  CLAUDE_SESSION_ID=$(jq -r --arg wid "$WINDOW" \
    '.terminals[]?.splitTerminals[]? | select(.windowId == $wid) | .claudeSessionId // empty' \
    "$JSON" 2>/dev/null)

  if [[ -z "$CLAUDE_SESSION_ID" ]] && [[ -f "$LOGFILE" ]]; then
    debug "REATTACH non-interactive: dumping log for $WINDOW"
    dump_filtered_log "$LOGFILE"
  else
    debug "REATTACH interactive (Claude): skipping log dump and clear for $WINDOW"
    SKIP_CLEAR=true  # Claude sessions need their display intact - they don't auto-redraw
  fi

  # Ensure environment variable is set for backticks (may have been lost on screen restart)
  "$SCREEN" -S "$FULL_SESSION_ID" -X setenv IMMORTERM_SCREEN_BINARY "$SCREEN"
  # Pass renames directory so C code writes title files to project-specific location
  [[ -n "$IMMORTERM_RENAMES_DIR" ]] && "$SCREEN" -S "$FULL_SESSION_ID" -X setenv IMMORTERM_RENAMES_DIR "$IMMORTERM_RENAMES_DIR"
fi

# Set VS Code terminal tab name BEFORE exec screen
# OSC 0 sequence sets terminal title - must be sent before screen takes over
# otherwise VS Code shows "screen-5.0.1" (the process name)
printf '\033]0;%s\007' "$DISPLAY_NAME"

# Disable screen's internal scrollback dump (use log file approach instead)
"$SCREEN" -S "$FULL_SESSION_ID" -X scrollback_dump off

# Clear screen's scrollback buffer AND display to prevent duplicate content
# The scrollback accumulates previous renders (Claude Code redraws on resize)
# BUT: Skip for Claude sessions - they don't auto-redraw and clearing blanks the display
if [[ "$SKIP_CLEAR" != "true" ]]; then
  # Reset scrollback to 0 then restore to clear it completely
  "$SCREEN" -S "$FULL_SESSION_ID" -X scrollback 0
  "$SCREEN" -S "$FULL_SESSION_ID" -X scrollback 50000
  "$SCREEN" -S "$FULL_SESSION_ID" -X clear
  debug "Cleared scrollback buffer for $FULL_SESSION_ID"
else
  debug "Skipped clear for Claude session $FULL_SESSION_ID"

  # For Claude sessions: schedule a delayed hardstatus refresh after reattachment.
  # This ensures the status bar is redrawn even if no resize occurs (same dimensions).
  # The background job waits for attachment to complete, then forces a refresh.
  (
    sleep 0.3  # Wait for attachment to complete
    "$SCREEN" -S "$FULL_SESSION_ID" -X redisplay 2>/dev/null
    debug "Forced redisplay for Claude session $FULL_SESSION_ID"
  ) &
fi

# Attach to the session using full session ID to avoid ambiguity
# Use -D -RR to forcefully detach any stale attachments (e.g., dead displays from crashed VS Code)
# before reattaching. This prevents "attached to dead display" issues.
debug "Attaching to: $FULL_SESSION_ID"
exec "$SCREEN" -D -RR -S "$FULL_SESSION_ID"
